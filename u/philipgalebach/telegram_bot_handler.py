from typing import Optional

import wmill
import json
import requests
import base64
from email.mime.text import MIMEText

def main(message: Optional[dict] = None, update_id: Optional[int] = None, **kwargs) -> dict:
    """
    Complete Telegram bot webhook handler for movie mood generation
    Handles Telegram webhook updates directly by accepting message and update_id parameters
    """
    
    try:
        # Reconstruct the telegram update object
        telegram_update = {
            "message": message,
            "update_id": update_id,
            **kwargs  # Include any other fields Telegram might send
        }
        
        print(f"Received Telegram webhook: {json.dumps(telegram_update, indent=2)}")
        print(f"Message: {message}")
        print(f"Update ID: {update_id}")
        
        # Handle case where message is None
        if message is None:
            print("No message received from Telegram")
            return {"status": "no_message", "error": "No message data received"}
        
        # Handle non-dict message (sometimes comes as string)
        if not isinstance(message, dict):
            print(f"Message is not dict, trying to parse: {message}")
            try:
                if isinstance(message, str):
                    message = json.loads(message)
                else:
                    return {"status": "invalid_format", "error": f"Message is {type(message)}, expected dict"}
            except json.JSONDecodeError as e:
                return {"status": "json_error", "error": f"Could not parse message as JSON: {str(e)}"}
        chat_id = message['chat']['id']
        
        # Check if message has text
        if 'text' not in message:
            return send_telegram_message(
                chat_id, 
                "ðŸŽ¬ Please send me a movie title and I'll tell you the mood words for it!"
            )
        
        text = message['text'].strip()
        print(f"Processing message: '{text}' from chat_id: {chat_id}")
        
        # Handle commands
        if text.startswith('/'):
            if text.lower() in ['/start', '/help']:
                welcome_message = (
                    "ðŸŽ¬ *Movie Mood Generator Bot* ðŸŽ­\n\n"
                    "Send me any movie title and I'll generate mood words that describe it!\n\n"
                    "*Examples:*\n"
                    "â€¢ Inception\n"
                    "â€¢ The Dark Knight\n"
                    "â€¢ Pulp Fiction\n"
                    "â€¢ Star Wars\n\n"
                    "Just type the movie name - no commands needed! âœ¨"
                )
                return send_telegram_message(chat_id, welcome_message, parse_mode="Markdown")
            else:
                return send_telegram_message(
                    chat_id, 
                    "ðŸ¤” Unknown command. Just send me a movie title!"
                )
        
        # If empty message
        if not text:
            return send_telegram_message(
                chat_id, 
                "ðŸŽ¬ Please send me a movie title!"
            )
        
        # Generate mood words for the movie
        print(f"Generating moods for movie: {text}")
        mood_result = generate_movie_moods(text)
        
        # Format response based on success/failure
        if mood_result.get('success', False):
            response_text = (
                f"ðŸŽ¬ *{mood_result['movie']}*\n\n"
                f"ðŸŽ­ **Mood Words:** {mood_result['moods']}\n\n"
                f"âœ¨ _Generated by {mood_result.get('model_used', 'AI')}_"
            )
            parse_mode = "Markdown"
            
            # Also send email and create Asana task with the results
            try:
                email_result = send_gmail_notification(mood_result['movie'], mood_result['moods'])
                print(f"Email notification result: {email_result}")
            except Exception as e:
                print(f"Failed to send email notification: {str(e)}")
                # Don't fail the whole request if email fails
            
            try:
                asana_result = create_asana_task(mood_result['movie'], mood_result['moods'])
                print(f"Asana task creation result: {asana_result}")
                
                # Send Slack notification after successful Asana task creation
                if asana_result.get('status') == 'task_created':
                    try:
                        slack_result = send_slack_message(
                            mood_result['movie'], 
                            mood_result['moods'], 
                            asana_result.get('task_url', None)
                        )
                        print(f"Slack notification result: {slack_result}")
                    except Exception as e:
                        print(f"Failed to send Slack notification: {str(e)}")
                        # Don't fail the whole request if Slack fails
                        
            except Exception as e:
                print(f"Failed to create Asana task: {str(e)}")
                # Don't fail the whole request if Asana fails
        else:
            error_msg = mood_result.get('error', 'Unknown error occurred')
            response_text = (
                f"âŒ Sorry, I couldn't generate mood words for '{text}'\n\n"
                f"Error: {error_msg}\n\n"
                f"Please try again with another movie title! ðŸŽ¬"
            )
            parse_mode = None
        
        # Send response back to user
        return send_telegram_message(chat_id, response_text, parse_mode=parse_mode)
        
    except Exception as e:
        print(f"Error in telegram bot handler: {str(e)}")
        # Try to send error message to user if possible
        try:
            if message and isinstance(message, dict) and 'chat' in message:
                chat_id = message['chat']['id']
                return send_telegram_message(
                    chat_id, 
                    f"ðŸš¨ Oops! Something went wrong. Please try again later.\n\nError: {str(e)}"
                )
        except:
            pass  # If we can't even send error message, just return error status
        
        return {
            "status": "error", 
            "error": str(e),
            "message_received": message,
            "update_id": update_id,
            "message_type": str(type(message))
        }


def generate_movie_moods(movie_title: str) -> dict:
    """
    Generate mood words for a movie using OpenRouter API
    """
    
    # Get OpenRouter API key from Windmill resource
    api_key = None
    
    try:
        # Get OpenRouter resource - try different paths silently
        openrouter_resource = None
        for resource_path in ["u/philipgalebach/thinner_openrouter", "philipgalebach/thinner_openrouter"]:
            try:
                openrouter_resource = wmill.get_resource(resource_path)
                break  # Found it, stop trying
            except:
                continue  # Try next path
        # Handle both string and dict resource formats
        if openrouter_resource:
            if isinstance(openrouter_resource, dict):
                api_key = openrouter_resource.get("api_key")
            else:
                api_key = openrouter_resource
    except Exception:
        pass  # wmill might not be available in local testing
    
    if not api_key:
        return {
            "movie": movie_title,
            "error": "OpenRouter API key not found. Please check Windmill resource configuration.",
            "success": False
        }
    
    # Simple prompt for mood generation
    prompt = f"Generate 3-5 mood words that describe the movie '{movie_title}'. Return only the mood words separated by commas. Examples: Dark, Mysterious, Intense, Complex, Thought-provoking"
    
    try:
        # Make OpenRouter API call
        response = requests.post(
            url="https://openrouter.ai/api/v1/chat/completions",
            headers={
                "Authorization": f"Bearer {api_key}",
                "Content-Type": "application/json",
                "HTTP-Referer": "https://windmill.dev",  # Optional. Site URL for rankings
                "X-Title": "Windmill Movie Mood Generator",  # Optional. Site title for rankings
            },
            data=json.dumps({
                "model": "google/gemini-2.0-flash-lite-001",  # Using the model from your example
                "messages": [
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "max_tokens": 100,
                "temperature": 0.7
            })
        )
        
        # Check if request was successful
        response.raise_for_status()
        
        # Parse response
        response_data = response.json()
        moods = response_data['choices'][0]['message']['content'].strip()
        
        return {
            "movie": movie_title,
            "moods": moods,
            "model_used": "google/gemini-2.0-flash-lite-001",
            "success": True
        }
        
    except requests.exceptions.RequestException as e:
        return {
            "movie": movie_title,
            "error": f"Request error: {str(e)}",
            "success": False
        }
    except KeyError as e:
        return {
            "movie": movie_title,
            "error": f"Response parsing error: {str(e)}",
            "response": response.text if 'response' in locals() else "No response",
            "success": False
        }
    except Exception as e:
        return {
            "movie": movie_title,
            "error": f"Unexpected error: {str(e)}",
            "success": False
        }


def create_asana_task(movie_title: str, mood_words: str) -> dict:
    """
    Create an Asana task with movie mood analysis results
    """
    
    try:
        # Get Asana token from Windmill resource
        asana_resource = wmill.get_resource("u/philipgalebach/asana")
        
        # Handle both string and dict resource formats
        if isinstance(asana_resource, dict):
            access_token = asana_resource.get("token")
        else:
            access_token = asana_resource
            
        if not access_token:
            return {
                "status": "error",
                "error": "Asana access token not found in resource"
            }
        
        # Asana API endpoint for creating tasks
        asana_api_url = "https://app.asana.com/api/1.0/tasks"
        
        # Headers for Asana API
        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }
        
        # Task payload
        task_data = {
            "data": {
                "name": movie_title,
                "notes": f"ðŸŽ­ Mood Words: {mood_words}\n\nâœ¨ Generated by Windmill Telegram Bot using OpenRouter AI",
                "projects": ["1210382636168258"]  # Your testing-philip-api project ID
            }
        }
        
        # Create the task
        response = requests.post(asana_api_url, headers=headers, json=task_data)
        response.raise_for_status()
        
        task_response = response.json()
        
        return {
            "status": "task_created",
            "task_id": task_response["data"]["gid"],
            "task_name": movie_title,
            "mood_words": mood_words,
            "task_url": f"https://app.asana.com/0/1210382636168258/{task_response['data']['gid']}"
        }
        
    except requests.exceptions.RequestException as e:
        return {
            "status": "creation_failed",
            "error": f"Asana API request failed: {str(e)}"
        }
    except Exception as e:
        return {
            "status": "unexpected_error", 
            "error": f"Unexpected error creating Asana task: {str(e)}"
        }


def send_gmail_notification(movie_title: str, mood_words: str) -> dict:
    """
    Send Gmail notification with movie mood results
    """
    
    try:
        # Get Gmail OAuth2 token from Windmill resource
        gmail_resource = wmill.get_resource("u/philipgalebach/pgalebach_gmail_send")
        
        # Handle both string and dict resource formats
        if isinstance(gmail_resource, dict):
            access_token = gmail_resource.get("token")
        else:
            access_token = gmail_resource
            
        if not access_token:
            return {
                "status": "error",
                "error": "Gmail access token not found in resource"
            }
        
        # Create email content
        subject = f"ðŸŽ¬ Movie Mood Analysis: {movie_title}"
        body = f"""
Hello!

A new movie mood analysis has been generated:

ðŸŽ¬ Movie: {movie_title}
ðŸŽ­ Mood Words: {mood_words}

Generated by your Windmill Telegram Bot using OpenRouter AI.

Best regards,
Your Movie Mood Bot ðŸ¤–
"""
        
        # Create MIME message
        message = MIMEText(body)
        message['To'] = 'philip.galebach@gmail.com'
        message['From'] = 'philip.galebach@gmail.com'
        message['Subject'] = subject
        
        # Encode the message
        raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode()
        
        # Send via Gmail API
        gmail_api_url = "https://gmail.googleapis.com/gmail/v1/users/me/messages/send"
        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "raw": raw_message
        }
        
        response = requests.post(gmail_api_url, headers=headers, json=payload)
        response.raise_for_status()
        
        return {
            "status": "email_sent",
            "message_id": response.json().get("id"),
            "movie": movie_title,
            "mood_words": mood_words
        }
        
    except requests.exceptions.RequestException as e:
        return {
            "status": "send_failed",
            "error": f"Gmail API request failed: {str(e)}"
        }
    except Exception as e:
        return {
            "status": "unexpected_error", 
            "error": f"Unexpected error sending Gmail: {str(e)}"
        }


def send_telegram_message(chat_id: int, text: str, parse_mode: Optional[str] = None) -> dict:
    """
    Send a message via Telegram bot
    """
    
    try:
        # Get Telegram resource
        telegram_auth = wmill.get_resource("u/philipgalebach/windmill_telegram_test2_bot")
        
        # Handle both string and dict resource formats
        if isinstance(telegram_auth, dict):
            bot_token = telegram_auth.get("token")
            if not bot_token:
                # Try different key names
                for key in ["bot_token", "api_token", "value"]:
                    if key in telegram_auth:
                        bot_token = telegram_auth[key]
                        break
        else:
            bot_token = telegram_auth
        
        if not bot_token:
            print("Failed to get Telegram bot token from resource")
            return {
                "status": "token_error",
                "error": "Bot token not found in resource",
                "chat_id": chat_id
            }
        
        url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
        
        payload = {
            "chat_id": chat_id,
            "text": text
        }
        
        if parse_mode:
            payload["parse_mode"] = parse_mode
        
        response = requests.post(url, json=payload)
        response.raise_for_status()
        
        return {
            "status": "message_sent",
            "response": response.json(),
            "chat_id": chat_id,
            "text_length": len(text)
        }
        
    except requests.exceptions.RequestException as e:
        print(f"Failed to send Telegram message: {str(e)}")
        return {
            "status": "send_failed",
            "error": str(e),
            "chat_id": chat_id
        }
    except Exception as e:
        print(f"Unexpected error sending message: {str(e)}")
        return {
            "status": "unexpected_error",
            "error": str(e),
            "chat_id": chat_id
        }


def send_slack_message(movie_title: str, mood_words: str, asana_task_url: Optional[str] = None) -> dict:
    """
    Send Slack message notification with movie mood results
    """
    
    try:
        # Get Slack token from Windmill resource
        slack_resource = wmill.get_resource("u/philipgalebach/philipgalebach_slack")
        
        # Handle both string and dict resource formats
        if isinstance(slack_resource, dict):
            slack_token = slack_resource.get("token")
        else:
            slack_token = slack_resource
            
        if not slack_token:
            return {
                "status": "error",
                "error": "Slack token not found in resource"
            }
        
        # Create Slack message content
        message_text = f"ðŸŽ¬ *New Movie Mood Analysis*\n\n*Movie:* {movie_title}\nðŸŽ­ *Mood Words:* {mood_words}\n\nâœ¨ Generated by Windmill Telegram Bot"
        
        # Add Asana task link if available
        if asana_task_url:
            message_text += f"\n\nðŸ“‹ <{asana_task_url}|View Asana Task>"
        
        # Slack API endpoint for posting messages
        slack_api_url = "https://slack.com/api/chat.postMessage"
        
        # Headers for Slack API
        headers = {
            "Authorization": f"Bearer {slack_token}",
            "Content-Type": "application/json"
        }
        
        # Message payload - sending to yourself (you can change the channel if needed)
        message_data = {
            "channel": "@philip.galebach",  # Send as DM to yourself
            "text": message_text,
            "mrkdwn": True
        }
        
        # Send the message
        response = requests.post(slack_api_url, headers=headers, json=message_data)
        response.raise_for_status()
        
        slack_response = response.json()
        
        if slack_response.get("ok"):
            return {
                "status": "message_sent",
                "channel": message_data["channel"],
                "movie": movie_title,
                "mood_words": mood_words,
                "message_ts": slack_response.get("ts")
            }
        else:
            return {
                "status": "slack_api_error",
                "error": slack_response.get("error", "Unknown Slack API error")
            }
        
    except requests.exceptions.RequestException as e:
        return {
            "status": "send_failed",
            "error": f"Slack API request failed: {str(e)}"
        }
    except Exception as e:
        return {
            "status": "unexpected_error", 
            "error": f"Unexpected error sending Slack message: {str(e)}"
        }
